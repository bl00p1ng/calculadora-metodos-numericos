<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Métodos Numéricos - Calculadora Avanzada</title>
        <link rel="stylesheet" href="css/styles.css">
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Calculadora de Métodos Numéricos</h1>
            </div>

            <div id="menu" class="menu">
                <div class="menu-item" onclick="app.showMethod('bisection')">
                    <h3>Bisección</h3>
                    <p>Encuentra raíces de funciones mediante división del intervalo</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('fixedPoint')">
                    <h3>Punto Fijo</h3>
                    <p>Resuelve ecuaciones mediante iteración de punto fijo</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('newton')">
                    <h3>Newton-Raphson</h3>
                    <p>Método de convergencia rápida usando derivadas</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('gaussJacobi')">
                    <h3>Gauss-Jacobi</h3>
                    <p>Resuelve sistemas de ecuaciones lineales iterativamente</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('gaussSeidel')">
                    <h3>Gauss-Seidel</h3>
                    <p>Versión mejorada del método de Jacobi</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('integration')">
                    <h3>Integración Numérica</h3>
                    <p>Calcula integrales definidas numéricamente</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('differentiation')">
                    <h3>Diferenciación Numérica</h3>
                    <p>Aproxima derivadas mediante diferencias finitas</p>
                </div>
                <div class="menu-item" onclick="app.showMethod('lagrange')">
                    <h3>Polinomio de Lagrange</h3>
                    <p>Interpolación polinomial de puntos dados</p>
                </div>
            </div>

            <!-- Contenido dinámico para cada método -->
            <div id="methodContent" class="content"></div>
        </div>

        <!-- Scripts -->
        <script>
            /**
         * Logger centralizado para depuración
         * Implementa un sistema robusto de logs con diferentes niveles
         */
        class Logger {
            /**
             * Constructor del logger
             * Inicializa el contenedor de logs
             */
            constructor() {
                this.logs = [];
                this.logContainer = null;
            }

            /**
             * Establece el contenedor HTML para mostrar los logs
             * @param {HTMLElement} container - Elemento DOM donde se mostrarán los logs
             */
            setContainer(container) {
                this.logContainer = container;
            }

            /**
             * Registra un mensaje con nivel de información
             * @param {string} message - Mensaje a registrar
             */
            info(message) {
                this._log('info', message);
            }

            /**
             * Registra un mensaje de éxito
             * @param {string} message - Mensaje a registrar
             */
            success(message) {
                this._log('success', message);
            }

            /**
             * Registra un mensaje de advertencia
             * @param {string} message - Mensaje a registrar
             */
            warning(message) {
                this._log('warning', message);
            }

            /**
             * Registra un mensaje de error
             * @param {string} message - Mensaje a registrar
             */
            error(message) {
                this._log('error', message);
            }

            /**
             * Método interno para registrar logs
             * @param {string} level - Nivel del log (info, success, warning, error)
             * @param {string} message - Mensaje a registrar
             * @private
             */
            _log(level, message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    timestamp,
                    level,
                    message
                };
                
                this.logs.push(logEntry);
                console.log(`[${level.toUpperCase()}] ${timestamp}: ${message}`);
                
                if (this.logContainer) {
                    const logElement = document.createElement('div');
                    logElement.className = `log-entry ${level}`;
                    logElement.textContent = `[${timestamp}] ${message}`;
                    this.logContainer.appendChild(logElement);
                    this.logContainer.scrollTop = this.logContainer.scrollHeight;
                }
            }

            /**
             * Limpia todos los logs
             */
            clear() {
                this.logs = [];
                if (this.logContainer) {
                    this.logContainer.innerHTML = '';
                }
            }
        }

        /**
         * Clase base para todos los métodos numéricos
         * Define la interfaz común y funcionalidad compartida
         */
        class NumericalMethod {
            /**
             * Constructor de la clase base
             * @param {string} name - Nombre del método numérico
             * @param {Logger} logger - Instancia del logger para depuración
             */
            constructor(name, logger) {
                this.name = name;
                this.logger = logger;
                this.iterations = [];
                this.result = null;
            }

            /**
             * Valida los parámetros de entrada
             * @param {Object} params - Parámetros a validar
             * @returns {boolean} - True si los parámetros son válidos
             */
            validateParams(params) {
                this.logger.info(`Validando parámetros para ${this.name}`);
                return true;
            }

            /**
             * Ejecuta el cálculo del método numérico
             * @param {Object} params - Parámetros del cálculo
             * @throws {Error} - Debe ser implementado por las subclases
             */
            calculate(params) {
                throw new Error('El método calculate debe ser implementado por la subclase');
            }

            /**
             * Obtiene los resultados formateados
             * @returns {Object} - Resultados del cálculo
             */
            getResults() {
                return {
                    result: this.result,
                    iterations: this.iterations
                };
            }

            /**
             * Evalúa una función matemática dada como string
             * @param {string} func - Función matemática como string
             * @param {number} x - Valor en el que evaluar la función
             * @returns {number} - Resultado de la evaluación
             */
            evaluateFunction(func, x) {
                try {
                    // Reemplaza x en la función y evalúa
                    const expression = func.replace(/x/g, `(${x})`);  // Reemplaza x por el valor actual
                    return Function('"use strict"; return (' + expression + ')')();  // Evalúa la expresión
                } catch (error) {
                    this.logger.error(`Error evaluando función: ${error.message}`);
                    throw new Error('Función inválida');
                }
            }
        }

        /**
         * Implementación del método de Bisección
         * Encuentra raíces de funciones continuas en un intervalo
         */
        class BisectionMethod extends NumericalMethod {
            /**
             * Constructor del método de Bisección
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Bisección', logger);
            }

            /**
             * Ejecuta el método de bisección
             * @param {Object} params - Parámetros del cálculo
             * @param {string} params.function - Función a evaluar
             * @param {number} params.a - Límite inferior del intervalo
             * @param {number} params.b - Límite superior del intervalo
             * @param {number} params.tolerance - Tolerancia del error
             * @param {number} params.maxIterations - Máximo número de iteraciones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo por método de Bisección');
                const { function: func, a, b, tolerance, maxIterations } = params;
                
                let aVal = parseFloat(a);
                let bVal = parseFloat(b);
                let iter = 0;
                
                // Verifica que a y b sean válidos
                let fa = this.evaluateFunction(func, aVal);
                let fb = this.evaluateFunction(func, bVal);

                this.logger.info(`f(${aVal}) = ${fa}, f(${bVal}) = ${fb}`);
                
                // Verifica que los valores iniciales sean válidos
                if (fa * fb > 0) {
                    throw new Error('f(a) y f(b) deben tener signos opuestos');
                }
                
                this.iterations = [];
                this.result = null;
                
                while (iter < maxIterations) {
                    // Calcula el punto medio del intervalo actual [aVal, bVal]
                    let c = (aVal + bVal) / 2;

                    // Evalúa la función en el punto medio c
                    let fc = this.evaluateFunction(func, c);

                    // Calcula el error actual como la mitad de la longitud del intervalo
                    let error = Math.abs(bVal - aVal) / 2;
                    
                    this.iterations.push({
                        iteration: iter + 1,
                        a: aVal,
                        b: bVal,
                        c: c,
                        fc: fc,
                        error: error
                    });
                    
                    this.logger.info(`Iteración ${iter + 1}: c = ${c}, f(c) = ${fc}, error = ${error}`);
                    
                    // Verifica si se cumple el criterio de convergencia:
                    // Si el valor absoluto de f(c) es menor que la tolerancia (la función se acerca a cero)
                    // o si el error es menor que la tolerancia (el intervalo es suficientemente pequeño)
                    if (Math.abs(fc) < tolerance || error < tolerance) {
                        // Guarda el valor de la raíz encontrada
                        this.result = c;
                        // Registra en los logs que se alcanzó la convergencia y en cuántas iteraciones
                        this.logger.success(`Convergencia alcanzada en ${iter + 1} iteraciones`);
                        // Registra en los logs el valor de la raíz encontrada
                        this.logger.success(`Raíz encontrada: ${c}`);
                        // Sale del ciclo porque ya se encontró la solución
                        break;
                    }
                    
                    // Se evalúa el signo del producto f(a) * f(c) para determinar en qué subintervalo se encuentra la raíz.
                    // Si el producto es negativo, la función cambia de signo entre a y c ⇨ ahí está la raíz.
                    // De lo contrario, la raíz está entre c y b.
                    if (fa * fc < 0) {
                        // f(a) y f(c) tienen signos opuestos ⇒ la raíz está en [a, c]
                        bVal = c;   // Actualizamos el extremo superior del intervalo a c
                        fb = fc;    // Actualizamos el valor de f(b) con f(c)
                    } else {
                        // f(a) y f(c) tienen el mismo signo ⇒ la raíz está en [c, b]
                        aVal = c;   // Actualizamos el extremo inferior del intervalo a c
                        fa = fc;    // Actualizamos el valor de f(a) con f(c)
                    }

                    // Incrementamos el contador de iteraciones para el próximo ciclo
                    iter++;
                }
                
                if (!this.result) {
                    this.logger.warning('Máximo de iteraciones alcanzado sin convergencia');
                    this.result = (aVal + bVal) / 2;  // Devuelve el punto medio final como resultado
                }
            }
        }

        /**
         * Implementación del método de Punto Fijo
         * Resuelve ecuaciones de la forma x = g(x)
         */
        class FixedPointMethod extends NumericalMethod {
            /**
             * Constructor del método de Punto Fijo
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Punto Fijo', logger);
            }

            /**
             * Ejecuta el método de punto fijo
             * @param {Object} params - Parámetros del cálculo
             * @param {string} params.function - Función g(x) para x = g(x)
             * @param {number} params.x0 - Valor inicial
             * @param {number} params.tolerance - Tolerancia del error
             * @param {number} params.maxIterations - Máximo número de iteraciones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo por método de Punto Fijo');
                const { function: func, x0, tolerance, maxIterations } = params;
                
                let x = parseFloat(x0);
                let iter = 0;
                this.iterations = [];
                
                // Bucle principal que ejecuta hasta alcanzar las iteraciones máximas
                while (iter < maxIterations) {
                    // Evalúa la función g(x) en el punto actual x
                    const xNext = this.evaluateFunction(func, x);
                    // Calcula el error como la diferencia absoluta entre el nuevo valor y el anterior
                    const error = Math.abs(xNext - x);
                    
                    // Guarda la información de esta iteración para mostrarla después
                    this.iterations.push({
                        iteration: iter + 1,
                        x: x,               // Valor actual de x
                        xNext: xNext,       // Siguiente valor de x (g(x))
                        error: error        // Error calculado
                    });
                    
                    // Registra los valores de esta iteración en el log
                    this.logger.info(`Iteración ${iter + 1}: x = ${x}, g(x) = ${xNext}, error = ${error}`);
                    
                    // Si el error es menor que la tolerancia, se ha encontrado la solución
                    if (error < tolerance) {
                        // Guarda el resultado final
                        this.result = xNext;
                        // Registra el éxito en el log
                        this.logger.success(`Convergencia alcanzada en ${iter + 1} iteraciones`);
                        // Sale del ciclo porque ya se encontró la solución
                        break;
                    }
                    
                    // Actualiza x con el nuevo valor para la siguiente iteración
                    x = xNext;
                    // Incrementa el contador de iteraciones
                    iter++;
                }
                
                if (!this.result) {
                    this.logger.warning('Máximo de iteraciones alcanzado sin convergencia');
                    this.result = x;
                }
            }
        }

        /**
         * Implementación del método de Newton-Raphson
         * Método de convergencia rápida usando derivadas
         */
        class NewtonMethod extends NumericalMethod {
            /**
             * Constructor del método de Newton
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Newton-Raphson', logger);
            }

            /**
             * Calcula la derivada numérica de una función
             * @param {string} func - Función a derivar
             * @param {number} x - Punto donde calcular la derivada
             * @returns {number} - Valor de la derivada
             */
            /**
             * Calcula la derivada numérica de una función utilizando el método de diferencias centrales
             * @param {string} func - La función a derivar expresada como string
             * @param {number} x - El punto donde se desea calcular la derivada
             * @returns {number} - El valor aproximado de la derivada
             */
            calculateDerivative(func, x) {
                // Se define un paso pequeño para la aproximación numérica
                // Un valor muy pequeño mejora la precisión pero puede causar errores de redondeo
                const h = 0.0001; 
                
                try {
                    // Evalúa la función en el punto x+h
                    const f1 = this.evaluateFunction(func, x + h);
                    
                    // Evalúa la función en el punto x-h
                    const f2 = this.evaluateFunction(func, x - h);
                    
                    // Aplica la fórmula de diferencias centrales: f'(x) ≈ [f(x+h) - f(x-h)] / (2h)
                    // Este método proporciona una aproximación de segundo orden (error proporcional a h²)
                    return (f1 - f2) / (2 * h);
                } catch (error) {
                    // Si ocurre algún error durante la evaluación, se registra y se lanza una excepción
                    this.logger.error(`Error calculando derivada en x = ${x}: ${error.message}`);
                    throw new Error('Error al calcular la derivada');
                }
            }

            /**
             * Ejecuta el método de Newton-Raphson
             * @param {Object} params - Parámetros del cálculo
             * @param {string} params.function - Función f(x)
             * @param {number} params.x0 - Valor inicial
             * @param {number} params.tolerance - Tolerancia del error
             * @param {number} params.maxIterations - Máximo número de iteraciones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo por método de Newton-Raphson');
                const { function: func, x0, tolerance, maxIterations } = params;
                
                let x = parseFloat(x0);
                let iter = 0;
                this.iterations = [];
                this.result = null;

                this.logger.info(`Valor inicial: x0 = ${x}`);
                this.logger.info(`Función f(x) = ${func}`);
                
                while (iter < maxIterations) {
                    let fx, fpx;
                    
                    try {
                        // Evalúa la función y su derivada en el punto actual
                        fx = this.evaluateFunction(func, x);
                        fpx = this.calculateDerivative(func, x);
                    } catch (error) {
                        // Registra el error si hay problemas al evaluar la función o derivada
                        this.logger.error(`Error en iteración ${iter + 1}: ${error.message}`);
                        throw error;
                    }
                    
                    // Verifica que la derivada no sea cercana a cero para evitar divisiones peligrosas
                    // Una derivada muy pequeña puede causar problemas de convergencia
                    if (Math.abs(fpx) < 1e-10) {
                        this.logger.error(`Derivada muy pequeña en x = ${x}: f'(x) = ${fpx}`);
                        throw new Error('La derivada es muy pequeña, el método puede no converger');
                    }
                    
                    // Aplica la fórmula de Newton-Raphson: x_{n+1} = x_n - f(x_n)/f'(x_n)
                    const xNext = x - fx / fpx;
                    // Calcula el error como la diferencia absoluta entre el valor actual y el nuevo
                    const error = Math.abs(xNext - x);
                    
                    // Guarda los datos de esta iteración para mostrarlos después
                    this.iterations.push({
                        iteration: iter + 1,
                        x: x,
                        'f(x)': fx,
                        "f'(x)": fpx,
                        'x_next': xNext,
                        error: error
                    });
                    
                    // Registra los valores importantes de la iteración actual
                    this.logger.info(`Iteración ${iter + 1}: x = ${x}, f(x) = ${fx}, f'(x) = ${fpx}`);
                    this.logger.info(`x_next = ${xNext}, error = ${error}`);
                    
                    // Criterios de convergencia: si el error es menor que la tolerancia
                    // o si el valor de la función es casi cero, se ha encontrado la raíz
                    if (error < tolerance || Math.abs(fx) < tolerance) {
                        this.result = xNext;
                        this.logger.success(`Convergencia alcanzada en ${iter + 1} iteraciones`);
                        this.logger.success(`Raíz encontrada: ${xNext}`);
                        break;
                    }
                    
                    // Verificación de divergencia: valores extremadamente grandes o NaN
                    // indican que el método está fallando y no convergerá
                    if (Math.abs(xNext) > 1e10 || isNaN(xNext)) {
                        this.logger.error('El método está divergiendo');
                        throw new Error('El método diverge con el valor inicial dado');
                    }
                    
                    // Actualiza x con el nuevo valor para la siguiente iteración
                    x = xNext;
                    // Incrementa el contador de iteraciones
                    iter++;
                }
                
                if (!this.result) {
                    this.logger.warning('Máximo de iteraciones alcanzado sin convergencia');
                    this.result = x;
                }
            }
        }

        /**
         * Implementación del método de Gauss-Jacobi
         * Resuelve sistemas de ecuaciones lineales iterativamente
         */
        class GaussJacobiMethod extends NumericalMethod {
            /**
             * Constructor del método de Gauss-Jacobi
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Gauss-Jacobi', logger);
            }

            /**
             * Ejecuta el método de Gauss-Jacobi
             * @param {Object} params - Parámetros del cálculo
             * @param {Array<Array<number>>} params.matrix - Matriz de coeficientes
             * @param {Array<number>} params.vector - Vector de términos independientes
             * @param {Array<number>} params.initialGuess - Vector inicial
             * @param {number} params.tolerance - Tolerancia del error
             * @param {number} params.maxIterations - Máximo número de iteraciones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo por método de Gauss-Jacobi');
                const { matrix, vector, initialGuess, tolerance, maxIterations } = params;
                
                // Obtiene la dimensión del sistema de ecuaciones
                const n = matrix.length;
                // Copia el vector inicial para no modificarlo directamente
                let x = [...initialGuess];
                // Crea un nuevo array para almacenar los valores calculados en cada iteración
                let xNew = new Array(n).fill(0);
                let iter = 0;
                this.iterations = [];
                
                while (iter < maxIterations) {
                    // Para cada ecuación del sistema, calcula el nuevo valor de x[i]
                    for (let i = 0; i < n; i++) {
                        let sum = 0;
                        // Suma todos los términos a[i,j]*x[j] donde j ≠ i
                        for (let j = 0; j < n; j++) {
                            if (i !== j) {
                                sum += matrix[i][j] * x[j];
                            }
                        }
                        // Aplica la fórmula de Jacobi: x[i] = (b[i] - suma) / a[i,i]
                        xNew[i] = (vector[i] - sum) / matrix[i][i];
                    }
                    
                    // Calcula el error como la máxima diferencia entre los valores nuevos y anteriores
                    let error = 0;
                    for (let i = 0; i < n; i++) {
                        error = Math.max(error, Math.abs(xNew[i] - x[i]));
                    }
                    
                    // Guarda la información de esta iteración para visualizarla después
                    this.iterations.push({
                        iteration: iter + 1,
                        x: [...x],          // Vector actual
                        xNew: [...xNew],    // Vector calculado
                        error: error        // Error máximo
                    });
                    
                    // Muestra el progreso en el registro de log
                    this.logger.info(`Iteración ${iter + 1}: error = ${error}`);
                    
                    // Verifica si se alcanzó la convergencia deseada
                    if (error < tolerance) {
                        this.result = [...xNew];
                        this.logger.success(`Convergencia alcanzada en ${iter + 1} iteraciones`);
                        break;
                    }
                    
                    // Actualiza el vector x con los nuevos valores calculados para la siguiente iteración
                    x = [...xNew];
                    iter++;
                }
                
                if (!this.result) {
                    this.logger.warning('Máximo de iteraciones alcanzado sin convergencia');
                    this.result = [...xNew];
                }
            }
        }

        /**
         * Implementación del método de Gauss-Seidel
         * Versión mejorada del método de Jacobi con convergencia más rápida
         */
        class GaussSeidelMethod extends NumericalMethod {
            /**
             * Constructor del método de Gauss-Seidel
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Gauss-Seidel', logger);
            }

            /**
             * Ejecuta el método de Gauss-Seidel
             * @param {Object} params - Parámetros del cálculo
             * @param {Array<Array<number>>} params.matrix - Matriz de coeficientes
             * @param {Array<number>} params.vector - Vector de términos independientes
             * @param {Array<number>} params.initialGuess - Vector inicial
             * @param {number} params.tolerance - Tolerancia del error
             * @param {number} params.maxIterations - Máximo número de iteraciones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo por método de Gauss-Seidel');
                const { matrix, vector, initialGuess, tolerance, maxIterations } = params;
                
                // Obtiene la dimensión del sistema de ecuaciones lineales
                const n = matrix.length;
                // Crea una copia del vector inicial para comenzar las iteraciones
                let x = [...initialGuess];
                // Vector para almacenar valores de la iteración anterior
                let xOld = [...x];
                let iter = 0;
                this.iterations = [];
                
                while (iter < maxIterations) {
                    // Guarda los valores actuales antes de calcular los nuevos
                    xOld = [...x];
                    
                    // La diferencia clave con Jacobi: se usan valores actualizados inmediatamente
                    for (let i = 0; i < n; i++) {
                        let sum = 0;
                        for (let j = 0; j < n; j++) {
                            if (i !== j) {
                                // Usa los valores más recientes de x, lo que acelera la convergencia
                                sum += matrix[i][j] * x[j];
                            }
                        }
                        // Despeja la incógnita de la ecuación actual
                        x[i] = (vector[i] - sum) / matrix[i][i];
                    }
                    
                    // Calcula el error como la máxima diferencia entre valores nuevos y anteriores
                    let error = 0;
                    for (let i = 0; i < n; i++) {
                        error = Math.max(error, Math.abs(x[i] - xOld[i]));
                    }
                    
                    // Almacena los datos de esta iteración para mostrarlos después
                    this.iterations.push({
                        iteration: iter + 1,
                        xOld: [...xOld],     // Vector de valores anteriores
                        x: [...x],           // Vector de valores actualizados
                        error: error         // Error calculado
                    });

                    // Registra el progreso en el log
                    this.logger.info(`Iteración ${iter + 1}: error = ${error}`);

                    // Verifica si se alcanzó la convergencia deseada
                    if (error < tolerance) {
                        this.result = [...x];
                        this.logger.success(`Convergencia alcanzada en ${iter + 1} iteraciones`);
                        break;
                    }

                    // Incrementa el contador de iteraciones
                    iter++;
                }
            }
        }

        /**
         * Implementación de Integración Numérica
         * Calcula integrales definidas usando métodos numéricos
         */
        class NumericalIntegration extends NumericalMethod {
            /**
             * Constructor de Integración Numérica
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Integración Numérica', logger);
            }

            /**
             * Ejecuta la integración numérica usando el método del trapecio
             * @param {Object} params - Parámetros del cálculo
             * @param {string} params.function - Función a integrar
             * @param {number} params.a - Límite inferior de integración
             * @param {number} params.b - Límite superior de integración
             * @param {number} params.n - Número de subdivisiones
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo de integración numérica');
                const { function: func, a, b, n } = params;
                
                // Convierte los parámetros a números
                const aVal = parseFloat(a);
                const bVal = parseFloat(b);
                const nVal = parseInt(n);
                // Calcula el tamaño de cada subintervalo
                const h = (bVal - aVal) / nVal;
                
                this.iterations = [];
                let sum = 0;
                
                // Inicia el proceso de integración numérica usando la regla del trapecio
                for (let i = 0; i <= nVal; i++) {
                    // Calcula el punto x actual dentro del intervalo [a,b]
                    const x = aVal + i * h;
                    // Evalúa la función en el punto x actual
                    const fx = this.evaluateFunction(func, x);
                    
                    // Determina el peso según la posición:
                    // - Los puntos extremos (primero y último) tienen peso 0.5
                    // - Los puntos intermedios tienen peso 1
                    let weight = 1;
                    if (i === 0 || i === nVal) {
                        weight = 0.5;
                    }
                    
                    // Acumula la suma ponderada para la integración
                    sum += weight * fx;
                    
                    // Guarda los datos de este punto para mostrarlos en la tabla de resultados
                    this.iterations.push({
                        i: i,                      // Número de punto
                        x: x,                      // Valor de x
                        fx: fx,                    // Valor de f(x)
                        weight: weight,            // Peso asignado
                        contribution: weight * fx * h  // Contribución de este punto al resultado final
                    });
                }
                
                this.result = sum * h;
                this.logger.success(`Integral calculada: ${this.result}`);
            }
        }

        /**
         * Implementación de Diferenciación Numérica
         * Aproxima derivadas usando diferencias finitas
         */
        class NumericalDifferentiation extends NumericalMethod {
            /**
             * Constructor de Diferenciación Numérica
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Diferenciación Numérica', logger);
            }

            /**
             * Ejecuta la diferenciación numérica
             * @param {Object} params - Parámetros del cálculo
             * @param {string} params.function - Función a derivar
             * @param {number} params.x - Punto donde calcular la derivada
             * @param {number} params.h - Tamaño del paso
             * @param {string} params.method - Método a usar (forward, backward, central)
             */
            calculate(params) {
                // Inicia el proceso de cálculo y registra el evento en el log
                this.logger.info('Iniciando cálculo de diferenciación numérica');
                // Extrae los parámetros necesarios usando desestructuración
                const { function: func, x, h, method } = params;
                
                // Convierte los valores de texto a números para asegurar operaciones correctas
                const xVal = parseFloat(x);
                const hVal = parseFloat(h);
                
                // Inicializa el array que almacenará los datos de las iteraciones
                this.iterations = [];
                
                // Evalúa la función en el punto x inicial
                const fx = this.evaluateFunction(func, xVal);
                let derivative;
                
                // Dependiendo del método seleccionado, aplica una fórmula diferente
                switch (method) {
                    case 'forward':
                        // Método de diferencias hacia adelante: f'(x) ≈ [f(x+h) - f(x)] / h
                        // El usuario evalúa la función en un punto ligeramente adelante
                        const fxh = this.evaluateFunction(func, xVal + hVal);
                        derivative = (fxh - fx) / hVal;
                        // Guarda la información de la iteración para mostrarla después
                        this.iterations.push({
                            method: 'Diferencias hacia adelante',
                            x: xVal,
                            fx: fx,
                            'x+h': xVal + hVal,
                            'f(x+h)': fxh,
                            derivative: derivative
                        });
                        break;
                        
                    case 'backward':
                        // Método de diferencias hacia atrás: f'(x) ≈ [f(x) - f(x-h)] / h
                        // El usuario evalúa la función en un punto ligeramente atrás
                        const fxh2 = this.evaluateFunction(func, xVal - hVal);
                        derivative = (fx - fxh2) / hVal;
                        // Guarda la información de la iteración para mostrarla después
                        this.iterations.push({
                            method: 'Diferencias hacia atrás',
                            x: xVal,
                            fx: fx,
                            'x-h': xVal - hVal,
                            'f(x-h)': fxh2,
                            derivative: derivative
                        });
                        break;
                        
                    case 'central':
                        // Método de diferencias centrales: f'(x) ≈ [f(x+h) - f(x-h)] / (2h)
                        // Este método es más preciso porque evalúa la función en ambos lados
                        const fxh3 = this.evaluateFunction(func, xVal + hVal);
                        const fxh4 = this.evaluateFunction(func, xVal - hVal);
                        derivative = (fxh3 - fxh4) / (2 * hVal);
                        // Guarda la información de la iteración para mostrarla después
                        this.iterations.push({
                            method: 'Diferencias centrales',
                            x: xVal,
                            'x-h': xVal - hVal,
                            'f(x-h)': fxh4,
                            'x+h': xVal + hVal,
                            'f(x+h)': fxh3,
                            derivative: derivative
                        });
                        break;
                }
                
                // Almacena el resultado final para poder recuperarlo después
                this.result = derivative;
                // Registra el éxito de la operación en el log
                this.logger.success(`Derivada calculada: ${this.result}`);
            }
        }

        /**
         * Implementación del Polinomio de Lagrange
         * Realiza interpolación polinomial
         */
        class LagrangePolynomial extends NumericalMethod {
            /**
             * Constructor del Polinomio de Lagrange
             * @param {Logger} logger - Instancia del logger
             */
            constructor(logger) {
                super('Polinomio de Lagrange', logger);
            }

            /**
             * Calcula el polinomio de Lagrange y evalúa en un punto
             * @param {Object} params - Parámetros del cálculo
             * @param {Array<number>} params.xPoints - Valores x de los puntos
             * @param {Array<number>} params.yPoints - Valores y de los puntos
             * @param {number} params.xEval - Punto donde evaluar el polinomio
             */
            calculate(params) {
                this.logger.info('Iniciando cálculo del polinomio de Lagrange');
                const { xPoints, yPoints, xEval } = params;
                
                // Se obtiene la cantidad de puntos para interpolar
                const n = xPoints.length;
                // Se inicializa el resultado final a 0
                let result = 0;
                // Se prepara el arreglo que almacenará los datos de cada iteración
                this.iterations = [];
                
                // Se calcula cada término del polinomio de Lagrange
                // Cada término corresponde a un punto de los datos originales
                for (let i = 0; i < n; i++) {
                    // Se inicializa el polinomio base de Lagrange para el punto i
                    let li = 1;
                    // Variables para guardar el numerador y denominador separadamente (para mostrarlos)
                    let numerator = 1;
                    let denominator = 1;
                    
                    // Se construye el polinomio base Li(x) multiplicando todos los factores
                    for (let j = 0; j < n; j++) {
                        // Solo se incluyen términos donde j sea diferente de i
                        if (i !== j) {
                            // Se calcula el numerador como producto de (x - xj)
                            numerator *= (xEval - xPoints[j]);
                            // Se calcula el denominador como producto de (xi - xj)
                            denominator *= (xPoints[i] - xPoints[j]);
                            // Se calcula directamente el polinomio base Li(x)
                            li *= (xEval - xPoints[j]) / (xPoints[i] - xPoints[j]);
                        }
                    }
                    
                    // Se multiplica el polinomio base por el valor yi correspondiente
                    const term = yPoints[i] * li;
                    // Se suma al resultado acumulado
                    result += term;
                    
                    // Se almacena la información de esta iteración para mostrarla en la interfaz
                    this.iterations.push({
                        i: i,                     // Índice del punto actual
                        xi: xPoints[i],           // Coordenada x del punto
                        yi: yPoints[i],           // Coordenada y del punto
                        li: li,                   // Valor del polinomio base Li(x)
                        numerator: numerator,     // Numerador calculado
                        denominator: denominator, // Denominador calculado
                        term: term,               // Término completo yi*Li(x)
                        sumPartial: result        // Suma acumulada hasta el momento
                    });
                }
                
                // Se guarda el resultado final de la interpolación
                this.result = result;
                // Se registra el éxito de la operación en el log
                this.logger.success(`Valor interpolado: ${this.result}`);
            }
        }

        /**
         * Clase principal de la aplicación
         * Maneja la interfaz de usuario y coordina los métodos numéricos
         */
        class NumericalMethodsApp {
            /**
             * Constructor de la aplicación
             */
            constructor() {
                this.logger = new Logger();
                this.currentMethod = null;
                this.methods = {
                    bisection: new BisectionMethod(this.logger),
                    fixedPoint: new FixedPointMethod(this.logger),
                    newton: new NewtonMethod(this.logger),
                    gaussJacobi: new GaussJacobiMethod(this.logger),
                    gaussSeidel: new GaussSeidelMethod(this.logger),
                    integration: new NumericalIntegration(this.logger),
                    differentiation: new NumericalDifferentiation(this.logger),
                    lagrange: new LagrangePolynomial(this.logger)
                };
                
                this.logger.info('Aplicación de métodos numéricos inicializada');
            }

            /**
             * Muestra el formulario para un método específico
             * @param {string} methodName - Nombre del método a mostrar
             */
            showMethod(methodName) {
                this.logger.info(`Mostrando método: ${methodName}`);
                this.currentMethod = methodName;
                
                const menu = document.getElementById('menu');
                const content = document.getElementById('methodContent');
                
                menu.style.display = 'none';
                content.classList.add('active');
                
                // Genera el formulario según el método
                content.innerHTML = this.generateForm(methodName);
                
                // Configura el logger
                const logsContainer = document.getElementById('logs');
                if (logsContainer) {
                    this.logger.setContainer(logsContainer);
                    this.logger.clear();
                }
            }

            /**
             * Regresa al menú principal
             */
            goBack() {
                this.logger.info('Regresando al menú principal');
                const menu = document.getElementById('menu');
                const content = document.getElementById('methodContent');
                
                menu.style.display = 'grid';
                content.classList.remove('active');
                content.innerHTML = '';
            }

            /**
             * Genera el formulario HTML para cada método
             * @param {string} methodName - Nombre del método
             * @returns {string} - HTML del formulario
             */
            generateForm(methodName) {
                const forms = {
                    bisection: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Método de Bisección</h2>
                        
                        <div class="input-group">
                            <label for="function">Función f(x):</label>
                            <input type="text" id="function" placeholder="Ej: x^3 - x - 2" value="x^3 - x - 2">
                        </div>
                        
                        <div class="input-group">
                            <label for="a">Límite inferior (a):</label>
                            <input type="number" id="a" placeholder="Ej: 1" value="1">
                        </div>
                        
                        <div class="input-group">
                            <label for="b">Límite superior (b):</label>
                            <input type="number" id="b" placeholder="Ej: 2" value="2">
                        </div>
                        
                        <div class="input-group">
                            <label for="tolerance">Tolerancia:</label>
                            <input type="number" id="tolerance" placeholder="Ej: 0.0001" value="0.0001">
                        </div>
                        
                        <div class="input-group">
                            <label for="maxIterations">Máximo de iteraciones:</label>
                            <input type="number" id="maxIterations" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    fixedPoint: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Método de Punto Fijo</h2>
                        
                        <div class="input-group">
                            <label for="function">Función g(x) para x = g(x):</label>
                            <input type="text" id="function" placeholder="Ej: (x + 2)^(1/3)" value="(x + 2)^(1/3)">
                        </div>
                        
                        <div class="input-group">
                            <label for="x0">Valor inicial (x₀):</label>
                            <input type="number" id="x0" placeholder="Ej: 1.5" value="1.5">
                        </div>
                        
                        <div class="input-group">
                            <label for="tolerance">Tolerancia:</label>
                            <input type="number" id="tolerance" placeholder="Ej: 0.0001" value="0.0001">
                        </div>
                        
                        <div class="input-group">
                            <label for="maxIterations">Máximo de iteraciones:</label>
                            <input type="number" id="maxIterations" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    newton: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Método de Newton-Raphson</h2>
                        
                        <div class="input-group">
                            <label for="function">Función f(x):</label>
                            <input type="text" id="function" placeholder="Ej: x^3 - x - 2" value="x^5 - 205">
                        </div>
                        
                        <div class="input-group">
                            <label for="x0">Valor inicial (x₀):</label>
                            <input type="number" id="x0" placeholder="Ej: 1.5" value="2">
                        </div>
                        
                        <div class="input-group">
                            <label for="tolerance">Tolerancia:</label>
                            <input type="number" id="tolerance" placeholder="Ej: 0.0001" value="0.0001">
                        </div>
                        
                        <div class="input-group">
                            <label for="maxIterations">Máximo de iteraciones:</label>
                            <input type="number" id="maxIterations" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    gaussJacobi: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Método de Gauss-Jacobi</h2>
                        
                        <div class="input-group">
                            <label for="matrix">Matriz de coeficientes (A):</label>
                            <textarea id="matrix" rows="4" placeholder="Ej:&#10;4, -1, 0&#10;-1, 4, -1&#10;0, -1, 3">
10, 0, -1
4, 12, -4
4, 4, 10
                            </textarea>
                        </div>
                        
                        <div class="input-group">
                            <label for="vector">Vector de términos independientes (b):</label>
                            <input type="text" id="vector" placeholder="Ej: 15, 10, 10" value="1, 8, 4">
                        </div>
                        
                        <div class="input-group">
                            <label for="initialGuess">Vector inicial:</label>
                            <input type="text" id="initialGuess" placeholder="Ej: 0, 0, 0" value="0, 0, 0">
                        </div>
                        
                        <div class="input-group">
                            <label for="tolerance">Tolerancia:</label>
                            <input type="number" id="tolerance" placeholder="Ej: 0.0001" value="0.0001">
                        </div>
                        
                        <div class="input-group">
                            <label for="maxIterations">Máximo de iteraciones:</label>
                            <input type="number" id="maxIterations" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    gaussSeidel: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Método de Gauss-Seidel</h2>
                        
                        <div class="input-group">
                            <label for="matrix">Matriz de coeficientes (A):</label>
                            <textarea id="matrix" rows="4" placeholder="Ej:&#10;4, -1, 0&#10;-1, 4, -1&#10;0, -1, 3">
10, 0, -1
4, 12, -4
4, 4, 10
                            </textarea>
                        </div>
                        
                        <div class="input-group">
                            <label for="vector">Vector de términos independientes (b):</label>
                            <input type="text" id="vector" placeholder="Ej: 15, 10, 10" value="8, 4, -1">
                        </div>
                        
                        <div class="input-group">
                            <label for="initialGuess">Vector inicial:</label>
                            <input type="text" id="initialGuess" placeholder="Ej: 0, 0, 0" value="1, 2, 0">
                        </div>
                        
                        <div class="input-group">
                            <label for="tolerance">Tolerancia:</label>
                            <input type="number" id="tolerance" placeholder="Ej: 0.0001" value="0.0001">
                        </div>
                        
                        <div class="input-group">
                            <label for="maxIterations">Máximo de iteraciones:</label>
                            <input type="number" id="maxIterations" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    integration: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Integración Numérica</h2>
                        
                        <div class="input-group">
                            <label for="function">Función f(x):</label>
                            <input type="text" id="function" placeholder="Ej: x^2" value="x^2">
                        </div>
                        
                        <div class="input-group">
                            <label for="a">Límite inferior (a):</label>
                            <input type="number" id="a" placeholder="Ej: 0" value="0">
                        </div>
                        
                        <div class="input-group">
                            <label for="b">Límite superior (b):</label>
                            <input type="number" id="b" placeholder="Ej: 1" value="1">
                        </div>
                        
                        <div class="input-group">
                            <label for="n">Número de subdivisiones (n):</label>
                            <input type="number" id="n" placeholder="Ej: 100" value="100">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    differentiation: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Diferenciación Numérica</h2>
                        
                        <div class="input-group">
                            <label for="function">Función f(x):</label>
                            <input type="text" id="function" placeholder="Ej: x^2" value="x^2">
                        </div>
                        
                        <div class="input-group">
                            <label for="x">Punto x:</label>
                            <input type="number" id="x" placeholder="Ej: 2" value="2">
                        </div>
                        
                        <div class="input-group">
                            <label for="h">Tamaño del paso (h):</label>
                            <input type="number" id="h" placeholder="Ej: 0.01" value="0.01">
                        </div>
                        
                        <div class="input-group">
                            <label for="method">Método:</label>
                            <select id="method">
                                <option value="forward">Diferencias hacia adelante</option>
                                <option value="backward">Diferencias hacia atrás</option>
                                <option value="central" selected>Diferencias centrales</option>
                            </select>
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `,
                    
                    lagrange: `
                        <button class="back-button" onclick="app.goBack()">← Volver al menú</button>
                        <h2>Polinomio de Lagrange</h2>
                        
                        <div class="input-group">
                            <label for="xPoints">Valores de x (separados por comas):</label>
                            <input type="text" id="xPoints" placeholder="Ej: 0, 1, 2, 3" value="0, 1, 2, 3">
                        </div>
                        
                        <div class="input-group">
                            <label for="yPoints">Valores de y (separados por comas):</label>
                            <input type="text" id="yPoints" placeholder="Ej: 1, 2, 5, 10" value="1, 2, 5, 10">
                        </div>
                        
                        <div class="input-group">
                            <label for="xEval">Punto a evaluar:</label>
                            <input type="number" id="xEval" placeholder="Ej: 1.5" value="1.5">
                        </div>
                        
                        <div class="button-group">
                            <button class="calculate-button" onclick="app.calculate()">Calcular</button>
                        </div>
                        
                        <div id="results"></div>
                        <div class="logs" id="logs"></div>
                    `
                };
                
                return forms[methodName] || '';
            }

            /**
             * Ejecuta el cálculo del método actual
             */
            calculate() {
                this.logger.clear();
                this.logger.info(`Iniciando cálculo para método: ${this.currentMethod}`);
                
                try {
                    const params = this.getParameters();
                    const method = this.methods[this.currentMethod];
                    
                    // Valida parámetros y ejecuta el cálculo
                    if (method.validateParams(params)) {
                        method.calculate(params);
                        this.displayResults(method.getResults());
                    }
                } catch (error) {
                    this.logger.error(`Error: ${error.message}`);
                    this.displayError(error.message);
                }
            }

            /**
             * Obtiene los parámetros del formulario actual
             * @returns {Object} - Parámetros ingresados por el usuario
             */
            getParameters() {
                const params = {};
                
                switch (this.currentMethod) {
                    case 'bisection':
                        params.function = document.getElementById('function').value;
                        params.a = document.getElementById('a').value;
                        params.b = document.getElementById('b').value;
                        params.tolerance = parseFloat(document.getElementById('tolerance').value);
                        params.maxIterations = parseInt(document.getElementById('maxIterations').value);
                        break;
                        
                    case 'fixedPoint':
                    case 'newton':
                        params.function = document.getElementById('function').value;
                        params.x0 = document.getElementById('x0').value;
                        params.tolerance = parseFloat(document.getElementById('tolerance').value);
                        params.maxIterations = parseInt(document.getElementById('maxIterations').value);
                        break;
                        
                    case 'gaussJacobi':
                    case 'gaussSeidel':
                        // Parsea la matriz
                        const matrixText = document.getElementById('matrix').value;
                        params.matrix = matrixText.split('\n').map(row => 
                            row.split(',').map(val => parseFloat(val.trim()))
                        );
                        
                        // Parsea los vectores
                        params.vector = document.getElementById('vector').value
                            .split(',').map(val => parseFloat(val.trim()));
                        params.initialGuess = document.getElementById('initialGuess').value
                            .split(',').map(val => parseFloat(val.trim()));
                        
                        params.tolerance = parseFloat(document.getElementById('tolerance').value);
                        params.maxIterations = parseInt(document.getElementById('maxIterations').value);
                        break;
                        
                    case 'integration':
                        params.function = document.getElementById('function').value;
                        params.a = document.getElementById('a').value;
                        params.b = document.getElementById('b').value;
                        params.n = document.getElementById('n').value;
                        break;
                        
                    case 'differentiation':
                        params.function = document.getElementById('function').value;
                        params.x = document.getElementById('x').value;
                        params.h = document.getElementById('h').value;
                        params.method = document.getElementById('method').value;
                        break;
                        
                    case 'lagrange':
                        params.xPoints = document.getElementById('xPoints').value
                            .split(',').map(val => parseFloat(val.trim()));
                        params.yPoints = document.getElementById('yPoints').value
                            .split(',').map(val => parseFloat(val.trim()));
                        params.xEval = parseFloat(document.getElementById('xEval').value);
                        break;
                }
                
                return params;
            }

            /**
             * Muestra los resultados del cálculo
             * @param {Object} results - Resultados del método numérico
             */
            displayResults(results) {
                const resultsDiv = document.getElementById('results');
                let html = '<div class="results"><h3>Resultados</h3>';
                
                // Muestra el resultado principal
                if (results.result !== null) {
                    html += '<div class="result-item">';
                    if (Array.isArray(results.result)) {
                        html += '<strong>Solución:</strong><br>';
                        results.result.forEach((val, i) => {
                            html += `x${i + 1} = ${val.toFixed(6)}<br>`;
                        });
                    } else {
                        html += `<strong>Resultado:</strong> ${results.result.toFixed(6)}`;
                    }
                    html += '</div>';
                }
                
                // Muestra la tabla de iteraciones
                if (results.iterations && results.iterations.length > 0) {
                    html += '<h4>Iteraciones</h4>';
                    html += '<table class="iteration-table">';
                    
                    // Genera encabezados dinámicamente
                    const headers = Object.keys(results.iterations[0]);
                    html += '<tr>';
                    headers.forEach(header => {
                        html += `<th>${this.formatHeader(header)}</th>`;
                    });
                    html += '</tr>';
                    
                    // Genera las filas
                    results.iterations.forEach(iter => {
                        html += '<tr>';
                        headers.forEach(header => {
                            const value = iter[header];
                            if (typeof value === 'number') {
                                html += `<td>${value.toFixed(6)}</td>`;
                            } else if (Array.isArray(value)) {
                                html += `<td>[${value.map(v => v.toFixed(4)).join(', ')}]</td>`;
                            } else {
                                html += `<td>${value}</td>`;
                            }
                        });
                        html += '</tr>';
                    });
                    
                    html += '</table>';
                }
                
                html += '</div>';
                resultsDiv.innerHTML = html;
            }

            /**
             * Formatea los encabezados de la tabla
             * @param {string} header - Nombre del encabezado
             * @returns {string} - Encabezado formateado
             */
            formatHeader(header) {
                const headerMap = {
                    'iteration': 'Iteración',
                    'a': 'a',
                    'b': 'b',
                    'c': 'c',
                    'fc': 'f(c)',
                    'error': 'Error',
                    'x': 'x',
                    'xNext': 'x siguiente',
                    'fx': 'f(x)',
                    'fpx': "f'(x)",
                    'xOld': 'x anterior',
                    'xi': 'x_i',
                    'yi': 'y_i',
                    'li': 'L_i',
                    'term': 'Término',
                    'sumPartial': 'Suma parcial',
                    'weight': 'Peso',
                    'contribution': 'Contribución',
                    'derivative': 'Derivada',
                    'method': 'Método',
                    'numerator': 'Numerador',
                    'denominator': 'Denominador'
                };
                
                return headerMap[header] || header;
            }

            /**
             * Muestra un mensaje de error
             * @param {string} message - Mensaje de error a mostrar
             */
            displayError(message) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = `
                    <div class="error-message">
                        <strong>Error:</strong> ${message}
                    </div>
                `;
            }

        }

        // Inicializa la aplicación cuando se carga la página
        const app = new NumericalMethodsApp();
        </script>
    </body>
</html>